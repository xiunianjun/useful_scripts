#include <stdio.h>
/*
	体会位运算的妙用
	位运算：
	&：与	~：非 
	|：或	^：异或
	<<左移，删去最后一位，第一位补0.>>右移反之。
	利用位运算，我们可以实现一下功能： 
	
*/
int main(){
	
	
//	//判断一个数字的奇偶性

//	int m=14,n=13;//14：00 00 11 10 	13：00 00 11 01 
//	if((m & 1)==0){//注意，此处应取括号！！ 
//		printf("%d是偶数\n",m);
//		//TODO
//	} 
//	if((n & 1)==1){
//		printf("%d是奇数\n",n);
//		//TODO
//	}
//	


//	//判断一个二进制位是1还是0
//	
//	int number=30;//30：00 01 11 10
//	int n=5;
//	if(((number>>(n-1))&1)==0){//注意哦，右移不是一个算术语句，number值不变。 
//		printf("第%d位是0.\n",n);
//		//TODO
//	}else {
//		printf("第%d位是1.\n",n);
//	}
	
	
//	//交换两个整型变量的值
//	/*
//		***异或的性质***
//		1.交换律 a^b^c==a^c^b
//		2.结合律 (a^b)^c==a^(b^c)
//		3.任意x,x^x=0,x^o=x
//		4.自反性 A^B^B=A^0=A
//		 
//	*/ 
//	int m=14,n=13;
//	printf("一开始，m=%d,n=%d\n",m,n);
//	m=m^n;
//	n=m^n;
//	m=m^n;
//	printf("最后，m=%d,n=%d\n",m,n);
	
	
//	//不使用判断语句，求整数的绝对值
//	/*
//		注：>>:算术右移
//				最右侧不要了，最左侧补上符号位 
//		    >>>逻辑右移 
//		    	最右侧不要了，最左侧直接补0
//		注：对于int类型的数据，移位超出32位时要模32.
//		如，1<<35==1<<3 
//	*/
//	//似乎C语言只支持算术右移。。。逻辑右移达咩。。。 
//	int a=-1;
//	unsigned int b=(unsigned int)a>>>1;
//	printf("%d",b);


//	//实战：找出数组中唯一成对的数字
//	/*
//	1-10这10个数放在含有11个元素的数组中
//	只有唯一一个元素重复，其他均只出现一次
//	要求每个数组元素只能够被访问一次，
//	请设计一个算法，将它找出来，
//	不用辅助存储空间.
//	*/
//	//woc牛
//	/*
//	让0跟数组中所有数字异或，再跟1-10这十个数字异或，得到的最终结果就是那个数
//	运用性质后两条 
//	*/ 
//	int x=0;
//	int a[11]={1,3,5,2,4,10,9,6,7,8,5};
//	for(int i=0;i<11;i++){
//		x=x^a[i];
//		//TODO
//	}
//	for(int i=1;i<=10;i++){
//		x=x^i;
//		//TODO
//	}
//	printf("%d",x);


//	//实战2：找出落单的数
//	/*
//	一个数组中除了某一个元素中之外，
//	其他的元素都出现了两次，
//	请写程序找出这份只出现一次的数字
//	*/ 
//	//甚至只用异或一次
//	int x=0;
//	int a[]={1,1,2,2,3,3,6,6,7,7,5,4,4,8,8,9,9};
//	int size=sizeof(a)/sizeof(a[0]);
//	for(int i=0;i<size;i++){
//		x^=a[i];
//		//TODO
//	} 
//	printf("%d",x);


//	//实战3：输出一个整数二进制中1的个数
//法一：让整数不断右移，循环32次。 
//	int number=9;
//	int count=0;
//	for(int i=0;i<32;i++){
//		if(((number>>i)&1)==1){
//			count++;
//		}
//	} 
//	printf("%d",count);

////法二： N&(N-1)可以消掉一个1（为什么？你想想，牛逼）
////		故而不断循环，直到所有1被消掉，得到整数为0
////这个思路牛逼可拓展到很多有关二进制中1的题目
////如：判断一个数是否为2的幂次方（只有一个1） 
//	int x=9;
//	int count=0;
//	while(x!=0){
//		x=x&(x-1);
//		count++;
//		//TODO
//	}
//	printf("%d",count);


//	//将整数的奇偶位互换 
//	int number=9;
//	int gap1=0xaaaaaaaa;//此处a为十六进制，相当于1010 
//	int gap0=0x55555555;//此处5为十六进制，相当于0101 
//	int ji,ou;
//	ou=number&gap1;//保留number的偶数位 
//	ji=number&gap0;//保留number的奇数位 
//	number=(ou>>1)^(ji<<1);//奇数左移，偶数右移 
//	printf("%d",number);

    return 0;
}
